frontier = Queue()
frontier.put(start )
came_from = {}
came_from[start] = None

while not frontier.empty():
   current = frontier.get()

   if current == goal:
      break

   for next in graph.neighbors(current):
      if next not in came_from:
         frontier.put(next)
         came_from[next] = current



         def bfs(self):
               while queue:
                   path = queue.popleft()
                   x, y = path[-1]
                   if grid[y][x] == goal:
                       return path
                   for x2, y2 in ((x+1,y), (x-1,y), (x,y+1), (x,y-1)):
                       if 0 <= x2 < width and 0 <= y2 < height and self.trackMapFinal[y2][x2] != (0 or 1) and (x2, y2) not in seen:
                           queue.append(path + [(x2, y2)])
                           seen.add((x2, y2))

                           class decisionF:
                               def __init__ ( self, name= 'Davros' ):
                                   self.name = name
                                   self.directions = [ 'wait', 'up', 'down', 'right', 'left' ]
                                   self.last_result = 'Success'
                                   self.last_direction = 'down' #stores last direction moved
                                   self.switchx = 'right' #for switching directions left or right
                                   self.switchy = 'up' #for switching directions up or down
                                   self.pivot = 'up' #switching directions
                                   self.trackRow = 20 #for origin
                                   self.trackColumn = 20 #for origin
                                   #self.trackMapFinal = [['' for j in range(40)] for i in range(40)] #for keeping track of moves/walls
                                   self.trackMapTemp = [['' for j in range(40)] for i in range(40)] #for keeping track of moves/walls
                                   self.portal = (0,0)
                                   self.start = (20,20)
                                   self.trackMapFinal = np.arange(1600).reshape(40, 40)
                                   self.queue = collections.deque([[self.start]])
                                   self.seen = set([self.start])
